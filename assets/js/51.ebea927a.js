(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{658:function(t,a,v){"use strict";v.r(a);var _=v(8),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"一、事务的基本要素-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、事务的基本要素-acid"}},[t._v("#")]),t._v(" "),v("strong",[t._v("一、事务的基本要素（ACID）")])]),t._v(" "),v("h3",{attrs:{id:"原子性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[t._v("#")]),t._v(" 原子性")]),t._v(" "),v("p",[t._v("整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。")]),t._v(" "),v("h3",{attrs:{id:"一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[t._v("#")]),t._v(" 一致性")]),t._v(" "),v("p",[t._v("一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。")]),t._v(" "),v("p",[t._v("也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。")]),t._v(" "),v("h3",{attrs:{id:"隔离性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#隔离性"}},[t._v("#")]),t._v(" 隔离性")]),t._v(" "),v("p",[t._v("隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。")]),t._v(" "),v("h3",{attrs:{id:"持久性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#持久性"}},[t._v("#")]),t._v(" 持久性")]),t._v(" "),v("p",[t._v("在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。")]),t._v(" "),v("h2",{attrs:{id:"二、事务的并发问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、事务的并发问题"}},[t._v("#")]),t._v(" "),v("strong",[t._v("二、事务的并发问题")])]),t._v(" "),v("h3",{attrs:{id:"脏读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[t._v("#")]),t._v(" 脏读")]),t._v(" "),v("p",[t._v("事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据")]),t._v(" "),v("h3",{attrs:{id:"不可重复读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[t._v("#")]),t._v(" 不可重复读")]),t._v(" "),v("p",[t._v("事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。")]),t._v(" "),v("h3",{attrs:{id:"幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[t._v("#")]),t._v(" 幻读")]),t._v(" "),v("p",[t._v("系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。")]),t._v(" "),v("p",[t._v("小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表")]),t._v(" "),v("h2",{attrs:{id:"三、mysql事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、mysql事务隔离级别"}},[t._v("#")]),t._v(" "),v("strong",[t._v("三、MySQL事务隔离级别")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("事务隔离级别")]),t._v(" "),v("th",[t._v("脏读")]),t._v(" "),v("th",[t._v("不可重复读")]),t._v(" "),v("th",[t._v("幻读")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("读未提交（read-uncommitted）")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("是")])]),t._v(" "),v("tr",[v("td",[t._v("不可重复读（read-committed）")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td",[t._v("是")])]),t._v(" "),v("tr",[v("td",[t._v("可重复读（repeatable-read）")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("是")])]),t._v(" "),v("tr",[v("td",[t._v("串行化（serializable）")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td",[t._v("否")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);