(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{652:function(s,t,e){"use strict";e.r(t);var a=e(8),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("在Java开发时, 如果数据库连接 (Connection) 没有正确关闭, 会导致该连接一直被占用, 没有释放, 也就无法被重用或关闭, 最终会导致数据库连接的溢出, 无法获取连接, 程序也就挂了.")]),s._v(" "),e("p",[s._v("我们可以通过以下SQL来查询当前数据库的连接数, 正常情况下连接数会保持一定数量, 如果不是并发数突然增大的情况下.")]),s._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" username"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("count")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("username"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" v$"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("session")]),s._v("\n "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" username "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("is")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("not")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("null")]),s._v("\n "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("group")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" username\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("由于获取数据库连接比较耗时, 所以通常的做法是采用连接池, 一开始就获取一定量的连接数, 需要连接时就从连接池中获取一个, 标记成正在被使用, 别人就无法再获取这个连接, 使用完后不会关闭, 只是去除被使用的标示, 释放回连接池, 这时这个连接可以再次被使用, 一旦连接池中的连接都被使用, 这时要看连接池的管理策略, 一种策略是自动关闭超时的连接,这种情况下就比较难通过数据库的方面来查看连接是否正常, 只能另外通过其他办法排查, 另外一种策略是, 如果连接池中的连接都被使用, 就会重新再增加一个连接数, 所以在这种情况下, 如果有连接没有正常关闭, 等到连接池中的连接全部使用完, 通过oracle查询就会发现连接一直在增加.")])])}),[],!1,null,null,null);t.default=n.exports}}]);