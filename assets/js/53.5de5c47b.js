(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{660:function(t,e,a){"use strict";a.r(e);var n=a(8),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[t._v("#")]),t._v(" 分布式事务")]),t._v(" "),a("p",[t._v("Eureka：核心注册表信息， 对外提供http接口，底层存储结构")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("concurrentHashMap<String, Map<stirng,Lease<instanceInfo>>\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("事务管理者（TC/TM）：统计事务状态信息，判断事务是否提交还是回滚。groupId传到另外一个系统")]),t._v(" "),a("p",[t._v("TC：全局事务协调者-计算")]),t._v(" "),a("p",[t._v("TM：全局事务管理者-创建事务提交")]),t._v(" "),a("p",[t._v("RM：资源管理器-DataSourceProxy，ConnectionProxy")]),t._v(" "),a("p",[t._v("TCC：业务有侵入性")]),t._v(" "),a("h2",{attrs:{id:"分布式事务解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务解决方案"}},[t._v("#")]),t._v(" 分布式事务解决方案")]),t._v(" "),a("ul",[a("li",[t._v("消息队列\n增加消息队列\n发送消息放在事务提交成功后，消息队列重试\n2PC（两阶段提交）：发送消息（不能被消费） >  本地事务 > 发送可消费\nRabbitMQ如果没收到提交，会去询问")]),t._v(" "),a("li",[t._v("AT\n特点业务无侵入，正常事务步骤：\n建立连接 > 开启事务 > 执行方法 > wait >提交事务\n创建代理Connection，注意close不能关闭，只有实际commit后close\n需要数据库支持事务（innodb）")]),t._v(" "),a("li",[t._v("TCC\n两阶段提交（try，commit，cancel，例如：下单 > 冻结金额（try）> 成功 （commit） or 失败（cancel））")]),t._v(" "),a("li",[t._v("Saga\n异常的时候增加修复方法")]),t._v(" "),a("li",[t._v("XA\n数据库上锁")])]),t._v(" "),a("h2",{attrs:{id:"分布式id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式id"}},[t._v("#")]),t._v(" 分布式ID")]),t._v(" "),a("p",[t._v("数据库自增。 为了保证高可用，主从模式，存在延迟，主主模式 ，通过设置步长保证两个数据库生成不一样ID，例如：奇、偶数，扩展不好")]),t._v(" "),a("p",[t._v("号段模式-Tinyid。批量获取，用数据库保存当前最大ID和段长")]),t._v(" "),a("p",[t._v("雪花算法：long 64位")]),t._v(" "),a("p",[t._v("分布式锁：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("数据库：使用for update 实现")])]),t._v(" "),a("li",[a("p",[t._v('Redis：\nLock  加锁使用set ( "key", "value", "NX", "PX",  3000)\ntryLock setnx\nunLock:  使用Lua （if redis.call(\'get\', KEY[1]) == ARGV[1] then return redis.call(\'del\', KEY[1]) else return 0 end）判断Value相等才删除')]),t._v(" "),a("p",[t._v("实现组件：Redisson，红锁，可以依赖多个节点，发给三个有两个成功就成功")])]),t._v(" "),a("li",[a("p",[t._v("zookeeper：\n分布式协调服务，是目录结构。实现原理：创建临时有序节点，判断最小就是持有锁\ntryLock: 判断节点序号是否是最小，是获取到锁，如果不是，监听前一个节点，等待唤醒")])])]),t._v(" "),a("p",[t._v("HashMap:")]),t._v(" "),a("p",[t._v("1.8 : 链表长度大于8时，会变成红黑树，新增时加到列表的尾部，解决1.7死锁问题")]),t._v(" "),a("h2",{attrs:{id:"数据库扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库扩展"}},[t._v("#")]),t._v(" 数据库扩展")]),t._v(" "),a("ul",[a("li",[t._v("水平切分：数据库结构一模一样，存储根据一定规则把数据分散到不同的数据库中，如：取余方式决定存放到哪个数据库")]),t._v(" "),a("li",[t._v("垂直切分： 将不同的表分到不同数据库，分片只把表的字段拆分到不同数据库，如：根据业务类型分库")]),t._v(" "),a("li",[t._v("读写分离：主（master）节点写，从节（slave）点只读")])]),t._v(" "),a("p",[t._v("mycat: 数据库分库分表中间件")]),t._v(" "),a("p",[t._v("逻辑数据库，客户端直接操作这些逻辑数据库")])])}),[],!1,null,null,null);e.default=v.exports}}]);