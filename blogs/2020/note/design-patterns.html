<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>设计模式 | 艺术码农的小栈</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="IT是一门艺术">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.fd6f0cf4.css" as="style"><link rel="preload" href="/assets/js/app.e570317b.js" as="script"><link rel="preload" href="/assets/js/4.20b8dc2f.js" as="script"><link rel="preload" href="/assets/js/1.fa01cbc2.js" as="script"><link rel="preload" href="/assets/js/52.7f11a198.js" as="script"><link rel="prefetch" href="/assets/js/10.a1e795ad.js"><link rel="prefetch" href="/assets/js/11.0f8aee0d.js"><link rel="prefetch" href="/assets/js/12.2bab46fa.js"><link rel="prefetch" href="/assets/js/13.c4103c4c.js"><link rel="prefetch" href="/assets/js/14.1e874097.js"><link rel="prefetch" href="/assets/js/15.fb7c17bd.js"><link rel="prefetch" href="/assets/js/16.f995482f.js"><link rel="prefetch" href="/assets/js/17.849cc3ca.js"><link rel="prefetch" href="/assets/js/18.28625a15.js"><link rel="prefetch" href="/assets/js/19.29c64a42.js"><link rel="prefetch" href="/assets/js/20.ecb8a1dc.js"><link rel="prefetch" href="/assets/js/21.7089401a.js"><link rel="prefetch" href="/assets/js/22.e101207a.js"><link rel="prefetch" href="/assets/js/23.f32a25cc.js"><link rel="prefetch" href="/assets/js/24.4c45a8ac.js"><link rel="prefetch" href="/assets/js/25.60b07057.js"><link rel="prefetch" href="/assets/js/26.ae364031.js"><link rel="prefetch" href="/assets/js/27.0a649aa4.js"><link rel="prefetch" href="/assets/js/28.507ed731.js"><link rel="prefetch" href="/assets/js/29.7b8fcf5f.js"><link rel="prefetch" href="/assets/js/3.d446576d.js"><link rel="prefetch" href="/assets/js/30.18933227.js"><link rel="prefetch" href="/assets/js/31.9bbd1440.js"><link rel="prefetch" href="/assets/js/32.3be55b02.js"><link rel="prefetch" href="/assets/js/33.e5a4fb5a.js"><link rel="prefetch" href="/assets/js/34.6ccce21a.js"><link rel="prefetch" href="/assets/js/35.eb6ff691.js"><link rel="prefetch" href="/assets/js/36.96f01919.js"><link rel="prefetch" href="/assets/js/37.c396bd6f.js"><link rel="prefetch" href="/assets/js/38.700a3124.js"><link rel="prefetch" href="/assets/js/39.e100ccd0.js"><link rel="prefetch" href="/assets/js/40.88bf4db5.js"><link rel="prefetch" href="/assets/js/41.e109a044.js"><link rel="prefetch" href="/assets/js/42.13ea6c18.js"><link rel="prefetch" href="/assets/js/43.bff5209b.js"><link rel="prefetch" href="/assets/js/44.c7588fd9.js"><link rel="prefetch" href="/assets/js/45.c7a2c05f.js"><link rel="prefetch" href="/assets/js/46.2a55bf6d.js"><link rel="prefetch" href="/assets/js/47.2eb70008.js"><link rel="prefetch" href="/assets/js/48.80ec2507.js"><link rel="prefetch" href="/assets/js/49.4631f8e8.js"><link rel="prefetch" href="/assets/js/5.f8b726c1.js"><link rel="prefetch" href="/assets/js/50.ef29e8f7.js"><link rel="prefetch" href="/assets/js/51.4cec59d7.js"><link rel="prefetch" href="/assets/js/53.61242f1b.js"><link rel="prefetch" href="/assets/js/54.d1f179eb.js"><link rel="prefetch" href="/assets/js/55.f33321c2.js"><link rel="prefetch" href="/assets/js/56.2fb16d8d.js"><link rel="prefetch" href="/assets/js/57.169e1575.js"><link rel="prefetch" href="/assets/js/58.95211ddc.js"><link rel="prefetch" href="/assets/js/59.8389c0c4.js"><link rel="prefetch" href="/assets/js/6.be26a4fd.js"><link rel="prefetch" href="/assets/js/60.bfe2edcc.js"><link rel="prefetch" href="/assets/js/61.d2ff58b3.js"><link rel="prefetch" href="/assets/js/62.c9040e72.js"><link rel="prefetch" href="/assets/js/63.4ffff579.js"><link rel="prefetch" href="/assets/js/64.e28d33f1.js"><link rel="prefetch" href="/assets/js/65.d585eb74.js"><link rel="prefetch" href="/assets/js/66.b2601b0b.js"><link rel="prefetch" href="/assets/js/67.1b7f6877.js"><link rel="prefetch" href="/assets/js/68.93a3250a.js"><link rel="prefetch" href="/assets/js/69.235b84da.js"><link rel="prefetch" href="/assets/js/7.6051ac3d.js"><link rel="prefetch" href="/assets/js/70.49e52005.js"><link rel="prefetch" href="/assets/js/71.0c38cb5a.js"><link rel="prefetch" href="/assets/js/72.89843788.js"><link rel="prefetch" href="/assets/js/73.7874dd2d.js"><link rel="prefetch" href="/assets/js/74.26f08eca.js"><link rel="prefetch" href="/assets/js/75.63a472e0.js"><link rel="prefetch" href="/assets/js/76.a034a9fc.js"><link rel="prefetch" href="/assets/js/77.33033028.js"><link rel="prefetch" href="/assets/js/78.74e5d122.js"><link rel="prefetch" href="/assets/js/79.b10bae1e.js"><link rel="prefetch" href="/assets/js/8.76fd16fb.js"><link rel="prefetch" href="/assets/js/80.e38e5f46.js"><link rel="prefetch" href="/assets/js/81.2e4938b0.js"><link rel="prefetch" href="/assets/js/82.8d082810.js"><link rel="prefetch" href="/assets/js/83.0ee75fa1.js"><link rel="prefetch" href="/assets/js/9.842229ff.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fd6f0cf4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>艺术码农的小栈</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>IT是一门艺术</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Hyman</span>
            
          <span data-v-4e82dffc>2009 - </span>
          2025
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="艺术码农的小栈" class="logo"> <span class="site-name">艺术码农的小栈</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      随手笔记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/实践总结/" class="nav-link"><i class="undefined"></i>
  实践总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/K8S/" class="nav-link"><i class="undefined"></i>
  K8S
</a></li><li class="dropdown-item"><!----> <a href="/categories/笔记/" class="nav-link"><i class="undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/探索/" class="nav-link"><i class="undefined"></i>
  探索
</a></li><li class="dropdown-item"><!----> <a href="/categories/转载/" class="nav-link"><i class="undefined"></i>
  转载
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      主页
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/itart-top" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/piaohai" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    Hyman
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>73</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      随手笔记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/实践总结/" class="nav-link"><i class="undefined"></i>
  实践总结
</a></li><li class="dropdown-item"><!----> <a href="/categories/K8S/" class="nav-link"><i class="undefined"></i>
  K8S
</a></li><li class="dropdown-item"><!----> <a href="/categories/笔记/" class="nav-link"><i class="undefined"></i>
  笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/探索/" class="nav-link"><i class="undefined"></i>
  探索
</a></li><li class="dropdown-item"><!----> <a href="/categories/转载/" class="nav-link"><i class="undefined"></i>
  转载
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      主页
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/itart-top" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/piaohai" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>设计模式</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Hyman</span>
            
          <span data-v-4e82dffc>2009 - </span>
          2025
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">设计模式</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>Hyman</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2020/12/26</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>笔记</span><span class="tag-item" data-v-1ff7123e>设计模式</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="状态模式"><a href="#状态模式" class="header-anchor">#</a> 状态模式</h2> <p>状态模式用与解决系统中复杂对象的状态转换及不同状态下行为的封装问题。</p> <p><strong>定义：</strong></p> <p>允许一个对象在其内部状态改变时改变他的行为，对象看起来似乎修改了它的类。</p> <p>包含三个角色：</p> <ol><li><p>Context（环境类）：上下文类，拥有多种状态的的对象。包含：一个抽象的state的实例，定义当前状态，方法：request()，setState(State state)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Contest {
	private State state
	private  int Value
	public void setState(State state){
		this.state = state
	}
	public void request() {
		state.handle();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>State（抽象状态类）：定义一个接口以封装与环境类的一个特定状态相关的行为（handle），声明不同状态对应的方法，其子类实现。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class State{
	public abstract void handle();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreteState（具体状态类 ）：具体实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteState {
	public void handle() {
		xxx
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p>状态转换方式：</p> <ul><li><p>环境类负责状态转换</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void changeState() {
	if (value == 0) {
		this.setState(new ConcreteStateA())
	} else {
		this.setState(new ConcreteStateB())
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>具体状态实现类状态转换</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void changeState(Context ctx) {
	if (value == 0) {
		ctx.setState(new ConcreteStateA())
	} else {
		ctx.setState(new ConcreteStateB())
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul> <p><strong>主要优点</strong></p> <ol><li>封装了状态转换规则，状态转换封装在环境或具体状态类中，不是分散在一个个业务方法中</li> <li>状态有关的行为放在一个类中，注入一个不同的状态对象即可使环境对象拥有不同的行为</li> <li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块。</li> <li>多个环境对象共享一个状态对象，减少系统中对象的个数</li></ol> <p><strong>主要缺点</strong></p> <ol><li>增加系统的类和对象</li> <li>结构和实现比较复杂</li> <li>开闭原则支持不太好，增加新的状态需要修改那些负责状态转换的源码</li></ol> <p><strong>适用场景</strong></p> <ol><li>对象的行为依赖于它的状态，状态改变会导致行为的变化</li> <li>代码中包含大量与对象状态有关的条件语句</li></ol> <h2 id="观察者模式"><a href="#观察者模式" class="header-anchor">#</a> 观察者模式</h2> <p>一个对象发生变化时通知其他对象，其他对象将相应做出反应。</p> <p><strong>定义</strong></p> <p>定义对象之间一种一对多依赖关系，每当一个对象状态放生改变时，其相关依赖对象皆通知并被自动更新。别名：发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式，是一种对象行为型模式。</p> <ol><li><p>Subject（目标）：目标又称为主题，观察的对象。方法：增加/删除对象，通知方法notify()，可以是接口，也能是抽象类具体类。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Submit {
	protected ArrayList observers&lt;Observer&gt; = new ArrayList();
	public void attach(Observer observer){
		observers.add(observer);
	}
	public void detach(Observer observer){
		
	}
	public abstract void notify();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>ConcreteSubject（具体目标）：目标的子类，通常包含经常发生改变的数据，当数据发生改变，通知各个观察者。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteSubject extends Subject {
	public void notify() {
		for (Object obs:observers) {
			((Observer)abs).update();
		}
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>Observer（观察者）：定义观察目标的改变做出反应，一般定义为接口update方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Observer{
	public void update();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreteObserver（具体观察者）： 维护一个指向具体目标对象的引用，存储具体观察者的有关状态，实现update方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteObserver implements Observer{
	public void update() {
		xx
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p>JDK事件模型1.0采用责任链模式，改为观察者模式；</p> <p>MVC设计模式也是一种观察者模式；</p> <p><strong>主要优势</strong></p> <ol><li>实现表示层和逻辑层分离。</li> <li>目标和观察者之间建立一个抽象耦合。</li> <li>观察者支持广播通信</li> <li>观察者满足开闭原则</li></ol> <p><strong>主要缺点</strong></p> <ol><li>一个观察者观察目标对象有多个直接和间接观察者，所有观察者都通知会花费很多时间</li> <li>观察者和观察目标存在循环依赖。观察目标会触发它们之间的循环依赖，导致系统崩溃</li> <li>没有相应机制让观察者知道目标对象是怎么发生变化。</li></ol> <p><strong>使用场景</strong></p> <ol><li>一个抽象模式有两个方面，其中一个方面依赖另外一个方面，将这个两个方面封装在独立对象可以独立改变和复用</li> <li>一个对象改变将导致一个或多个对象也发生改变。</li> <li>需要系统创建一个触发链，A对象的行为将影响B对象，B对象行为将影响C对象..可以创建一种链式触发机制</li></ol> <h2 id="访问者模式"><a href="#访问者模式" class="header-anchor">#</a> 访问者模式</h2> <p>主要包含访问者和被访问两个主要组成部分，被访问的元素有不同类型，且不同访问者可以对它们进行不同的访问操作。</p> <p><strong>定义</strong></p> <p>提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作，访问者模式是一种对象的行为型模式。</p> <ol><li><p>Vistor（抽象访问者）：为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Vistor{
	public abstract void visit(ConcreateElementA elementA);
	public abstract void Visit(ConcreateElementB elementB);
	public void visit(ConcreteElementC elementC) {
		// 操作C
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作作用于访问对象结构中的一种类型的元素</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteVisitor extends Visitor{
	public void visit(ConcreteElementA elementA) {
		// 元素A的操作代码
	}
	public void visit(ConcreteElementB elementB) {
		// 元素B的操作代码
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>Element（抽象元素）：接口或抽象类，定义一个accept（）方法，该方法通常以一个抽象访问者作为参数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interfact Element{
	public void accept(Visitor visitor)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreateElement（具体访问者）：实现accept（）方法，方法中调用访问者的访问方法，完成对一个元素的操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteElmentA implements Element{
	public void accept(Vistor vistor){
		visitor.visit(this);
	}
	public void operationA() {
		// 业务方法
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>ObjectStructure（对象结构）：元素集合，提供了遍历其内部元素的方法，可以结合组合模式来实现，也可以是一个简单的集合对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ObjectStructure{
	private ArrayList&lt;Element&gt; list = new ArrayList&lt;Element&gt;();
	public void accept(Vistor vistor) {
		Iterator i = list.iterator()
		while(i.hasNext()) {
			((Element)i.next()).accept(vistor)
		}
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <p>访问者使用条件较为苛刻，本身复杂，实际使用频道不会很高。</p> <p><strong>主要优点</strong></p> <ol><li>增加新的访问者操作很方便</li> <li>有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个元素中，职责清晰。</li> <li>用户能够在不修改现有元素类层次结构的情况下，定义用于该层次结构的操作</li></ol> <p><strong>主要缺点</strong></p> <ol><li>增加新的元素很困难。违背开闭原则</li> <li>破坏封装。访问者要求访问对象并调用每个元素对象的操作。</li></ol> <p><strong>适用场景</strong></p> <ol><li>对象结构包含多个类型对象，希望对对象实施一些依赖其具体类型的操作</li> <li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，需要避免这些操作&quot;污染&quot;这些对象的类.</li> <li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li></ol> <h2 id="策略模式"><a href="#策略模式" class="header-anchor">#</a> 策略模式</h2> <p>定义一些独立的类来封装不同的算法，目的是为了将使用和定义分开。</p> <p><strong>定义</strong></p> <p>定义一系列算法，将每个算法封装起来，并让它们可以相互替换。</p> <ol><li><p>Context（环境类）：使用算法的角色，解决某个问题是可以采用多种策略，维持一个抽象策略的引用实例，用于定义所曹勇的策略</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Context{
	private AbstractStrategy strategy;
	public void setStrategy(AbstractStrategy strategy){
		this.strategy = strategy;
	}
	public void algorigthm() {
		strategy.algorithm();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>Strategy（抽象策略类）：声明抽象方法，是所有策略的分类，可以是抽象类、具体类，也可以是接口。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class AbstractStrategy{
	public abstract void algorithm();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreteStrategy（具体策略类）：实现了再抽象策略类中声明的算法，在运行时，具体策略将覆盖环境类中定义的抽象策略类对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreateStrategyA extends AbstractStrategy{
	public void algorithm() {
		//
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p>典型应用实例：Container &gt; LayoutManager &gt; (FlowLayout，GridLayout)</p> <p><strong>主要优点</strong></p> <ol><li>符合开闭原则，可以不修改原有系统的基础上选择算法或增加算法</li> <li>提供了管理相关算法族的族。继承、公共的代码移到抽象策略类中，避免重复的代码。</li> <li>可以替换继承关系的办法。</li> <li>避免多重条件选择语句。</li> <li>算法复用机制。</li></ol> <p><strong>主要缺点</strong></p> <ol><li>客户端必须知道所有的策略类。</li> <li>会产生很多具体策略类。</li> <li>无法同时在客户端使用多个策略类</li></ol> <p><strong>使用场景</strong></p> <ol><li>一个系统需要动态地在几种算法中选择一种</li> <li>一个对象有很多的行为</li> <li>不希望客户端知道复杂的与算法相关的数据结构，在具体策略中封装算法与相关数据结构，可以提高算法的保密性与安全性。</li></ol> <h2 id="模板方法"><a href="#模板方法" class="header-anchor">#</a> 模板方法</h2> <p>模板方法提供了一个模板方法定义算法框架，具体步骤的实现可以在其子类中完成。</p> <p><strong>定义</strong></p> <p>定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变一个算法的结构即可重定义该算法的某些特定的步骤。模板方法是一种类型行为模式。</p> <ol><li><p>AbstractClass（抽象类）：定义一一系列基本操作，可以是具体也可以是抽象，每个基本操作对应算法的一个步骤，在其子类可以重定义或实现这些步骤。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class AbstractClass{
	public void templateMethod() {
		primitiveOperation1();
		primitiveOperation2();
	}
	public void primitiveOperation1(){
		xx
	}
	public abstract void primitiveOperation2(); 
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>ConcreteClass（具体子类）：抽象类的子类，实现父类中声明的抽象方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteClass extends AbstractClass{
	public void primitiveOperation2(){
		// 实现
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p><strong>主要优点</strong></p> <ol><li>在父类形式化地定义一个算法，子类实现细节，实现详细的处理算法不会改变算法中步骤的执行次序</li> <li>代码复用技术</li> <li>反向控制，子类覆盖父类的方法。符合单一职责、开闭原则</li></ol> <p><strong>主要缺点</strong></p> <p>要为每个基本方法的不同实现提供一个子类，会导致类变多</p> <p><strong>适用场景</strong></p> <ol><li>对一些复杂的算法进行分割，固定不变设计为模板方法和父类具体方法，改变的细节有子类实现</li> <li>公共行为提取到父类，避免代码重复</li> <li>通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反控。</li></ol> <h2 id="命令模式"><a href="#命令模式" class="header-anchor">#</a> 命令模式</h2> <p>命令模式可以将请求发送者和接收者完全解耦，发送者和接收者之间没有直接引用关系，发送只要知道如何发送，不必知道如何完成请求</p> <p><strong>定义</strong></p> <p>将一个请求封装为一个对象，从而可用不同的请求对客户端进行参数化。</p> <ol><li><p>Command（抽象命令类）；一般是接口或抽象类，声明了用与执行的execute()方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Command{
	public abstract void execute();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreteCommand（具体命令类）：抽象美丽类的子类，实现execute方法，他对应具体的接收者对象，将接收者对象的动作绑定其中。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public ConcreteCommand extends Command{
	private Receiver receiver;
	public void execute() {
		receiver.action();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>Invoker（调用者）：请求发送者，它通过命令对象来执行请求，不需要在设计时确定其接收者，只与抽象命令类之间存在关系。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Invoker{
	private Command command;
	public Invoker(Command command) {
		this.command=command;
	}
	public void call() {
		command.execute();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>Receiver（接收者）：执行与请求相关的操作，具体实现对请求的业务处理。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Receiver{
	public void action(){
		...
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p><strong>主要优点</strong></p> <ol><li>降低系统的耦合度。</li> <li>新的命令容易加入到系统中。符合开闭原则。</li> <li>容易设计一个命令队列或宏命令</li> <li>为请求的撤销/恢复提供了一种设计和实现方案</li></ol> <p><strong>主要缺点</strong></p> <p>过多具体命令类。</p> <p><strong>适用场景</strong></p> <ol><li>请求调用者和接收者解耦。请求无效知道接收者存在，接收者也无须关心何时被调用</li> <li>系统支持撤销/恢复操作</li> <li>需要一组操作组合在一起形成宏命令</li></ol> <h2 id="备忘录模式"><a href="#备忘录模式" class="header-anchor">#</a> 备忘录模式</h2> <p>提供了一种状态恢复的实现机制。</p> <p>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p> <ol><li><p>Originator（原发器）：普通类，可以创建一个备忘录，存储当前内部状态，也可以恢复其内部状态。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class Originator{
	private String state;
	public Memento createMemento() {
		return new Memento(this);
	}
	public void restoreMemento(Memento m) {
		state = m.state
	}
	public String getState() {
		return this.state;
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p>Memento（备忘录）：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Memento{
	private String state;
	public Memento(Originator o) {
		state = o.getState();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>Caretaker（负责人）：又称为管理者，负责保存备忘录，但是不能对备忘录的内容进行操作或检查。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class Catetaker{
	private Memento memento;
	public Memento getMemento() {
		return memento;
	}
	public void setMemento(Memento memento) {
		this.memento = memento;
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <p><strong>主要优点</strong></p> <ol><li>提供了一个状态恢复的实现机制</li> <li>实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码改动。</li></ol> <p><strong>主要缺点</strong></p> <p>资源消耗过大</p> <p><strong>使用场景</strong></p> <ol><li>保存一个对象在某一个时刻的全部或部分状态，需要时恢复，提供撤销功能</li> <li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</li></ol> <h2 id="解释器模式"><a href="#解释器模式" class="header-anchor">#</a> 解释器模式</h2> <p><strong>定义</strong></p> <p>定义一个语言的文法，建立一个解释器来解耦该语言中的句子，这里的“语言”是指使用规定格式和语法的代码</p> <ol><li><p>AbstractExpression（抽象表达式）：声明了抽象的解释操作，终结和非总结符表达式的公共父类</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class AbstractionExpression{
	public abstract void interpret(Context ctx);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>TerminalExpression（终结符表达式）：AbstractExpression子类，每个总结符都是该类的一个实例</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class TerminalExpression extends AbstractExpression{
	public void interpret(Context ctx){
		// 终结表达式的解释操作
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>NonterminalExpression（非终结符表达式）：AbstractExpression子类，非终结符的解释操作，解释操作一般通过递归的方式来完成</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class NoterminalExpression extends AbstractExpression{
	private AbstractExpression left;
	private AbstractExpression right;
	public NoterminalExpression(AbstractExpression left, AbstractExpression right){
		this.left = left;
		this.right = right;
	}
	pbulic void interpret(Context ctx){
		// 递归调用每一个组成成员
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p>Context（环境类）：又称为上下文类，存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Context{
	private HashMap map = newHashMap();
	publiv void assign(string key, string value){
		// 设值
	}
	public string lookup(String key){
		// 获取存储的值
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <h2 id="组合模式"><a href="#组合模式" class="header-anchor">#</a> 组合模式</h2> <p>让叶子对象和容器对象的使用具有一致性。</p> <p><strong>定义</strong></p> <p>组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构</p> <ol><li><p>Component（抽象构件）：接口或抽象类，为子构件和容器对象声明接口，可以包含所有子类公用有的行为的声明和实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Component{
	public abstract void add(Component c);
	public abstract void remove(Component c);
	public abstract void getChild(int i);
	public abstract void operation(Component c);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>Leaf（叶子构件）：没有子节点，实现抽象构件定义的行为</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Leaf extends Component{
	public void add(Component c){
		// 异常或错误提示
	}
	public void remove(Component c){
		// 异常或错误提示
	}
	public void getChild(int i){
		// 异常或错误提示
	}
	public void operation(Component c){
		// 操作
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li> <li><p>Composite（容器构件）：包含子节点，实现抽象构件定义的行为</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Comosite extends Component{
	private ArrayList&lt;Component&gt; list = new ArrayList&lt;Component&gt;()
	public void add(Component c){
		list.add(c)
	}
	public void remove(Component c){
		list.remove(c)
	}
	public void getChild(int i){
		return list.get(i)
	}
	public void operation() {
		for (Object obj: list){
			((Component)obj).operation();
		}
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ol> <p>Java SE中的AWT和Swing包的设计就是基于组合模式。</p> <p><strong>主要优点</strong></p> <ol><li>清晰定义分层次的复杂对象，表示对象的全部和部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li> <li>客户端可以一致使用组合结构或其中的单个对象，不关心是单个还是组合，简化客户端。</li> <li>增加容器和叶子很方便，符合开闭原则</li> <li>为树形结构提供了灵活的解决方案</li></ol> <p><strong>缺点</strong></p> <ol><li>难对容器中的类型进行限制。</li></ol> <p><strong>适用场景</strong></p> <ol><li>整体和部分层次结构，希望忽略差异，客户端可以一致对待它们</li> <li>树形结构</li> <li>树形结构，分离出叶子对象和容器对象，且它们的类型不固定，希望增加新的类型。</li></ol> <p><strong>桥接模式</strong></p> <p>系统中某个类存在独立变化的维度，通过桥接模式可以将这两个维度分离出来，使两者可以独立扩展。</p> <p><strong>定义</strong></p> <p>将抽象部分和其实现部分分离，使它们都可以独立地变化。</p> <ol><li><p>Abstraction（抽象类）：抽象类或接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Abstraction{
	protected Implementor impl;
	public void setImpl(Implementor impl){
		this.impl = impl;
	}
	public abstract void operation();// 声明抽象业务方法
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>RefinedAbstraction（扩充抽象类）：定义接口，通常情况是具体类，不是抽象类，实现Abstraction中的抽象业务方法，可以调用Implementor中定义的业务方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class RefinedAbstraction extends Abstraction{
	public void operation() {
		// 业务代码
		impl.operationImpl();
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>Implementor（实现类接口）：可以和Abstraction完全不同，定义基本操作。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Implementor{
	public void operationImpl();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>ConcreteImplementor（具体实现类）：实现Implementor接口</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteImplementor implement Implementor{
	public void operationImpl(){
		// xx
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p>Java虚拟机和JDBC等驱动程序的核心模式之一。</p> <p><strong>主要优点</strong></p> <ol><li>分离抽象和实现。</li> <li>可以取代多继承方案</li> <li>提高里系统的扩展性</li></ol> <p><strong>主要缺点</strong></p> <ol><li>增加系统理解和设计的难道，关联建立在抽象层，要求开发者一开始就要针对抽象层进行设计</li> <li>要求正确识别系统中两个独立变化的维度，使用范围有一定局限性。</li></ol> <p><strong>适用场景</strong></p> <ol><li>抽象类和具体类之间增加更多的灵活性，避免两个层次建立静态的继承关系。</li> <li>抽象和实现部分可以以继承方式扩展而互不影响。</li> <li>类中存在独立变化的维度。</li> <li>不希望通过继承方式扩展。</li></ol> <h2 id="外观模式"><a href="#外观模式" class="header-anchor">#</a> 外观模式</h2> <p>一个子系统的外部和内部通讯通过一个统一的外观角色进行，将客户端与子系统中的内部复杂性分开。</p> <p><strong>定义</strong></p> <p>外部与一个子系统通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致入口。</p> <ol><li>Facade（外观角色）：定义相关系统的功能和职责</li> <li>SubSystem（子系统角色）：可以有一个或多个子系统角色，不是单独的类，而是一个类的集合，实现子系统的功能。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Facade{
	private  SubSystemA obj1= new SubSystemA();
	private SubSystemB obj2 = new SubSystemB();
	..
	public void method() {
		obj1.method();
		obj2.method();
		....
	}

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>简化客户端和子系统的交付，为复杂的子系统提供一个统一的入口。菜单和工具类就是B/S系统的外观角色。</p> <p><strong>主要优点</strong></p> <ol><li>客户端屏蔽子系统组件</li> <li>子系统和客户端之间松耦合</li> <li>子系统修改对其他子系统没有影响</li> <li>提供一个访问子系统的统一入口</li></ol> <p><strong>主要缺点</strong></p> <ol><li>不能好好限制客户端使用子系统类</li> <li>设计不当，添加子系统需要修改外观模式的源码，违背开闭原则</li></ol> <p><strong>适用场景</strong></p> <ol><li>复杂子系统提供一个简单入口</li> <li>客户端和多个子系统存在很大的依赖关系</li> <li>层次结构中，可以使用外观模式定义系统中每一层的入口，层次之间不直接产生联系，通过外观降低耦合度</li></ol> <h2 id="中介者模式"><a href="#中介者模式" class="header-anchor">#</a> 中介者模式</h2> <p>简化对象之间的复杂交互，迪米特法则的一个典型应用。</p> <p><strong>定义</strong></p> <p>封装一系列对象交互，使各对象不需要显式地相互引用，使其耦合松散，可以独立改变它们之间的交互。</p> <ol><li><p>Mediator（抽象中介者）：定义一个接口，该接口用于与各同事对象之间进行通信</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Mediator{
	Protected ArrayList&lt;Colleague&gt; colleagues;
	// 注册，增加同事对象
	public void register(Colleague colleague) {
		colleagues.add(colleagure)
	}
	public abstract void operation(c Colleague);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>ConcreteMediator（具体中介者）：Mediator子类，协调各个同事对象来协作行为，维持了对各个同事对象的引用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class ConcreateMediator extends Mediator{
	public void operation(c Colleague){
		(Colleague)(Colleagues.get(0))).method1();// 通过中介者调用同事类方法
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>Colleague（抽象同事）：各个同事类公有方法，声明了一些抽象方法来供子类实现，同时维持了一个抽象中介者类的引用，子类可以通过该引用来与中介者通信</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>abstract class Colleague{
	protected Mediator meditor;
	public Colleague(Mediator mediator){
		this.meditor = meditor
	}
	public abstract void method1();
	public void update(){
		mediator.operation(this);// 与中介者通信
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>ConcreateColleague（具体同事类）：Colleague的子类，和其他同事通信先与中介通信，通过中介者间接完成与其他同事类的通信。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ConcreteColleague extends Colleague{
	public ConcreteColleague(Mediator mediator){
		super(mediator);
	}
	public void method1(){
		...
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ol> <p>客户端直接通过调用具体同事类的update()方法调用中介者和其他同事通信。</p> <p>中介者将一个网状的系统结构变成一个以中介者为中心的星状结构，代替原来的多对多关系，事件驱动软件中用的比较广泛，特别是基于GUI的应用软件。</p> <p><strong>主要优点</strong></p> <ol><li>简化了对象之间的交互，一对多代替了原来的多对多。</li> <li>将各个同事之间解耦</li> <li>减少同事子类生成，将原本分布于多个对象之间的行为集中在一起。</li></ol> <p><strong>主要缺点</strong></p> <ol><li>中介者类中包含大量同事之间的交互细节，可能会导致中介者复杂，系统难以维护</li></ol> <p><strong>适用场景</strong></p> <ol><li>系统中对象之间存在复杂引用，结构混乱</li> <li>一个对象由于引用了其他很多对象，并且直接和对象通信，导致难以复用</li> <li>想通过一个中间类分装多个类中的行为，而又不想生成太多子类。</li></ol> <h2 id="享元模式"><a href="#享元模式" class="header-anchor">#</a> 享元模式</h2> <p>通过技术实现相同或相似对象的重用。</p> <p><strong>定义</strong></p> <p>支持大量细粒度对象的复用。</p> <ol><li><p>Flyweight（抽象享元类）：一个接口或抽象类，声明了具体享元的公共方法</p></li> <li><p>ConcreteFlyweight（具体享元类）：实现Flyweight，内部提供了存储空间</p></li> <li><p>UnsharedConcreteFlyweight（非共享具体享元类）：不同共享的子类可设计为非共享具体享元类。</p></li> <li><p>FlyweightFactory（享元工厂类）：创建、管理享元对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class FlyweightFactory{
	private HashMap flyweights = new HashMap();
	public Flywight getFlyweight(string key){
		if (flyweights.ContainsKey(key)){
			return (Flywight)flyweights.get(key);
		} else {
			Flyweight fw = new ConcreteFlyweight();
			flyweights.put(key, fw);
			return fw;
		}
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ol> <p>系统中存在大量的相同或者相似的对象时，可以考虑使用该模式</p> <p><strong>主要优点</strong></p> <ol><li>减少内存中的对象的数量</li> <li>外部状态独立，不会影响其内部状态</li></ol> <p><strong>主要缺点</strong></p> <ol><li>系统变为复杂</li> <li>对象可以共享，需要分离出内部状态和外部状态。</li></ol> <p><strong>适用场景</strong></p> <ol><li>系统中存在大量相同或相似的对象。</li> <li>对象的大状态可以外部化。</li> <li>多次重复使用享元对象</li></ol></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#状态模式" class="sidebar-link reco-side-状态模式" data-v-70334359>状态模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#观察者模式" class="sidebar-link reco-side-观察者模式" data-v-70334359>观察者模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#访问者模式" class="sidebar-link reco-side-访问者模式" data-v-70334359>访问者模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#策略模式" class="sidebar-link reco-side-策略模式" data-v-70334359>策略模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#模板方法" class="sidebar-link reco-side-模板方法" data-v-70334359>模板方法</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#命令模式" class="sidebar-link reco-side-命令模式" data-v-70334359>命令模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#备忘录模式" class="sidebar-link reco-side-备忘录模式" data-v-70334359>备忘录模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#解释器模式" class="sidebar-link reco-side-解释器模式" data-v-70334359>解释器模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#组合模式" class="sidebar-link reco-side-组合模式" data-v-70334359>组合模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#外观模式" class="sidebar-link reco-side-外观模式" data-v-70334359>外观模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#中介者模式" class="sidebar-link reco-side-中介者模式" data-v-70334359>中介者模式</a></li><li class="level-2" data-v-70334359><a href="/blogs/2020/note/design-patterns.html#享元模式" class="sidebar-link reco-side-享元模式" data-v-70334359>享元模式</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.e570317b.js" defer></script><script src="/assets/js/4.20b8dc2f.js" defer></script><script src="/assets/js/1.fa01cbc2.js" defer></script><script src="/assets/js/52.7f11a198.js" defer></script>
  </body>
</html>
